---
title: "Noise Analysis 20-1000 Hz"
output:
  html_document:
    df_print: paged
---

```{r libraries, include = FALSE}
library(lubridate) # for handling dates

# graphs
library(tidyverse) # for wrangling and graphs
library(ggrepel) # for repelling labels on the graph
#library(ggpubr) # using ggarrange
#library(qqplotr) # qq plots
library(viridis) # to use viridis color palette
library(ggExtra) # for removeGrid
library(ggprism) # add minor tick marks to ggplot

# stats
library(lme4) # for mixed models
library(lmerTest) # get p-values for lmer for spatial
#library(broom.mixed) # to run augment on an lmer model
#library(MuMIn) # to get R squared of lmer

library(emmeans) # for pairwise comparisons

#library(MASS) # for negative binomial linear regressions
#library(broom) # making predictions from linear models
library(car) # running an Anova test for season

library(insight) # to get R squared of rlmer
library(robustlmm) # to run rlmer
library(effects) # graphs of rlmer results

# maps
library(ggmap) # making maps
library(ggsn) # add scale bar

# tables
#library(kableExtra) # print stat tables
library(flextable) # build stats table

#knitr::purl("noise_analysis.Rmd")
#NCmisc::list.functions.in.file("noise_analysis.R")
options(scipen = 100, digits = 4)
```

```{r data_wrangling, eval = FALSE, include = FALSE}
# below was the procedure to initially process the files; I have saved the resulting file, negating the need to re-run

datapath = "/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/recording_files"
setwd(datapath)
txt_files_ls = list.files(path = datapath, pattern = "*.txt")
txt_files_df <- lapply(txt_files_ls, function(x) 
    {read.table(file = x, header = TRUE, sep ="\t")})
combined_dfl <- do.call("rbind", lapply(txt_files_df, as.data.frame))
combined_dfl$Time <- strptime(combined_dfl$Time, format = "%H:%M:%S")
combined_dfl$Hour <-hour(combined_dfl$Time)
pca_results <- readRDS("/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/data/pca_results.rds") %>% 
  mutate(Site = site, .keep = "unused")
combined_dfl <- full_join(combined_dfl, pca_results, by = "Site")

# Calculate the daily average leq for each 24-hour recording at each site
dayavgl <- combined_dfl %>% 
  mutate(Substrate = fct_recode(factor(Substrate), "Plant" = "Plant", "Manmade" = "Artificial", "Manmade" = "Artifical")) %>% 
  rename(Traffic_Impact = `Traffic Impact`) %>% 
  group_by(Site, Visit, Mic, Category, Substrate, Material, Dim.1, Dim.2, Traffic_Impact) %>% 
  summarize(mean_leq = mean(Leq, na.rm = TRUE), 
            med_leq = median(Leq, na.rm = TRUE),
            mean_aggent = mean(AggEnt, na.rm = TRUE))

prephouravgcatl <- combined_dfl %>% 
  group_by(Site, Visit, Mic, Hour, Category, Substrate, Material) %>% 
  summarize(meanleq = mean(Leq, na.rm = TRUE),
            med_leq = median(Leq, na.rm = TRUE))

houravgcatl <- prephouravgcatl %>% 
  mutate(dark_light = as.numeric(ifelse(Hour >= 7, Hour - 7, Hour + 17)))

# get the average leq for each site
siteavgl <- combined_dfl %>% 
  group_by(Site, Category) %>% 
  summarize(mean_leq = mean(Leq, na.rm = TRUE),
            med_leq = median(Leq, na.rm = TRUE)) 

saveRDS(dayavgl, "/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/data/dayavgl.rds")
saveRDS(houravgcatl, "/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/data/houravgcatl.rds")
saveRDS(siteavgl, "/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/data/siteavgl.rds")
```

```{r import, include = FALSE}
# daily average (of 5 second time bins) leq for each 24-hour recording (20-1000 Hz)
dayavgl <- readRDS("/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/data/dayavgl.rds") %>% 
  mutate(Category = fct_relevel(Category, "Rural", "Urban"))
dayavgl_rev <- dayavgl %>% 
  mutate(Category = fct_relevel(Category, "Urban", "Rural"))

# hourly average (of 5 second time bins) leq for each 24-hour recording (20-1000 Hz)
houravgcatl <- readRDS("/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/data/houravgcatl.rds") %>% 
  mutate(Category = fct_relevel(Category, "Rural", "Urban"))

# site average (of 5 second time bins) leq for each site (20-1000 Hz)
siteavgl <- readRDS("/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/data/siteavgl.rds") %>% 
  mutate(Category = fct_relevel(Category, "Rural", "Urban"))

# coordinates of Lincoln's city limits
lincoln <- data.frame(read.table("/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/data/lincoln_coordinates.txt", sep = "," , header = F)) %>% 
  slice(10:2350) %>% 
  separate(V1, c("extra", "longitude", "latitude"), " ") %>% 
  mutate(longitude = as.numeric(longitude),
         latitude = as.numeric(latitude))
# coordinates of Wilderness Park borders
wilderness <- data.frame(read.table("/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/data/wilderness_coordinates.txt", sep = "," , header = F)) %>% 
  pivot_longer(V1:V211, names_to = "extra", values_to = "V1") %>% 
  slice(10:2350) %>% 
  separate(V1, c("extra2", "longitude", "latitude"), " ") %>% 
  mutate(longitude = as.numeric(longitude),
         latitude = as.numeric(latitude))

# site coordinates
sites <- read.csv("/Users/bjpessman/Documents/phd_research_code/Vibratory_Noise/data/site_coordinates.csv", header = TRUE) %>% 
  mutate(Site = Sites, .keep = "unused") 

visit_date <- read.csv("data/visit_date.csv", header = TRUE) %>% 
  mutate(Date = mdy(Date))

# Add dates to the daily average leq file
dayavgl <- full_join(dayavgl, visit_date, by = c("Site", "Visit"))

dayavgl_20 <- dayavgl %>% 
  filter(Date < "2021-01-01") %>% 
  mutate(Date = ymd(Date)) %>% 
  mutate(Day = as.numeric(yday(Date)),
         Visit = factor(Visit))

highlights <- dayavgl_20 %>% 
  filter(mean_leq == max(dayavgl_20$mean_leq) | mean_leq == min(dayavgl_20$mean_leq)) %>% 
  mutate(mean_leq = round(mean_leq, 2))
```

# Overview Figures 

Let's start by looking at the site distribution. We can color the sites based on their designated category (urban vs rural). We will also highlight Wilderness Park due to collections that happen there for the activity monitoring of *Agelenopsis pennsylvanica*. We will also fill the site labels of the sites where *A. pennsylvanica* are collected for the lab choice test. 

```{r site_map, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}
# add site coordinates to site average leq
sites <- full_join(sites, siteavgl, by = "Site") %>% 
  mutate(mean_leq = round(mean_leq),
         med_leq = round(med_leq)) %>% 
  mutate(choice = ifelse(Site == "8A" | Site == "8B", "Urban", 
                         ifelse(Site == "5A" | Site == "6C", "Rural", "Other")),
         choice = factor(choice),
         choice = fct_relevel(choice, "Rural", "Urban", "Other"))

# get Nebraska and Lancaster maps; I didn't use the Nebraska map here
nebraska <- map_data("state") %>% 
  subset(region == "nebraska")
lancaster <- map_data("county") %>% 
  subset(region == "nebraska") %>% 
  subset(subregion == "lancaster")

# adjust main map view
lc_borders <- c(bottom  = min(lancaster$lat) + 0.05, 
                 top     = max(lancaster$lat)  - 0.13,
                 left    = min(lancaster$long) - 0.01,
                 right   = max(lancaster$long) - 0.05)
map <- get_stamenmap(lc_borders, zoom = 10, maptype = "toner")

# final plot
site_map <- ggmap(map) + 
  ggsn::scalebar(x.min = -96.9, x.max = -96.5, y.min = 40.57, y.max = 40.899,
           dist = 5, dist_unit = "km", transform = TRUE, location = "bottomleft", 
           st.bottom = FALSE, box.color = c("black", "black"), st.size = 4, border.size = 0.5, 
           st.dist = 0.03) + # add scalebar
  geom_polygon(data = lincoln, aes(x = longitude, y = latitude), fill = "slategray", alpha = 0.25, color = "gray30") + # adds lincoln city limits outline/fill
  geom_polygon(data = wilderness, aes(x = longitude, y = latitude), fill = "#7570b3", color = "gray30") + # adds wilderness parks outline/fill
  geom_point(data = sites, mapping = aes(x = Longitude, y = Latitude, group = Category, color = Category), pch=21, size = 1, fill = "black", stroke = 2) + # plots coordinates of sites
  geom_label_repel(aes(x =Longitude, y = Latitude, label = Site, group = Category, color = Category, fill = choice), min.segment.length = 0.1, max.overlaps = Inf, size = 3, data = sites, show.legend  = FALSE) + # adds labels for sites and fills some and not others
  scale_color_manual("Category", values = c( "#1B9E77", "#D95F02")) + #colored by category
  scale_fill_manual("Category", values = c("#90ecd1", "#febd8c", "white")) +
  ylab("Latitude") + xlab("Longitude") + # x and y labels
  labs(fill = "Avg. Leq (dB)") + # legend title
  theme_classic() + 
  theme(panel.border = element_rect(colour = "black", fill = NA, linewidth = 1)) + # black panel border
  theme(legend.position = c(0.75, 0.05),
        legend.direction = "horizontal",
        legend.background = element_rect(fill = "grey95",
                                  linewidth = 0.5, linetype = "solid", 
                                  colour ="black")) + # legend properties
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 8, color = "black", family = "sans"),
        legend.text = element_text(size = 8, color = "black", family = "sans"),
        legend.title = element_text(size = 8, color = "black", family = "sans")) # text sizes

jpeg("figures/sites.jpeg", width = 4.5, height = 6, units = "in", quality = 100, res = 300) # save it as a certain size
print(site_map)
dev.off()

site_map
```

Sites are randomly distributed across Lincoln, Nebraska (urban) and into the surrounding rural area (rural).

Let's now take a look at a summary of the vibratory noise recorded across the experiment. Here, we order sites by the lowest average Leq (left) to the highest average Leq (right). Sites are divided along the horizontal axis and further divided by visit number. Microphones are divided across the vertical axis, further separated by substrate and hour. Each box represents the average Leq of an hour. Missing bars indicate failed recording trials (i.e., the microphone fell during recording or received damage from wildlife).

```{r vibemap, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}
# this data frame adds a mic number (either 1 or 2) instead of the recording unit number (which can vary from 1 to 12); will just reduce empty spaces in the final plot
mic_mic2 <- read.csv("data/mic_mic2.csv")
vibmap <- full_join(houravgcatl, mic_mic2, by = c("Site", "Substrate", "Mic")) %>% 
  mutate(Substrate = ifelse(Substrate == "Plant", "Plant", "Manmade")) %>% 
  unite("Sub_Mic", c(Substrate, Mic2), sep = "_") %>% 
  filter(! Sub_Mic == "Manmade_NA", ! Sub_Mic == "Plant_NA") %>% 
  mutate(Site = factor(Site), 
         Site = fct_relevel(Site, "6B", "6C", "5A", "7B", "6A", "7A", "1B", "1C", "2C", "3B", "5B", "8A", "2B", "3C", "2A", "7C", "1A", "4C", "3A", "4B", "4A", "5C", "8B"))

# recorder the sites by site average Leq
sites <- sites %>% 
  mutate(holder = 1,
         Site = factor(Site), 
         Site = fct_relevel(Site, "6B", "6C", "5A", "7B", "6A", "7A", "1B", "1C", "2C", "3B", "5B", "8A", "2B", "3C", "2A", "7C", "1A", "4C", "3A", "4B", "4A", "5C", "8B")) 

# a representation of the site average Leq that can be added to the top of the final figure
vibe_sites <- ggplot(sites, aes(x = Site, y = holder, fill = mean_leq)) +
  geom_tile(color = "white", size = 0.1, na.rm = TRUE) + 
  scale_fill_viridis(name = "Site Leq", option = "C") + 
  theme_minimal(base_size = 8) +
  labs(x = "Site", y = "Average Leq") +
  theme(legend.position = "none") +
  theme(strip.background = element_rect(colour = "white")) +
  theme(axis.ticks = element_blank()) +
  theme(axis.text.y = element_blank()) +
  theme(axis.text.x = element_text(size = 6, color = "black", family = "sans")) +
  theme(axis.title = element_blank()) +
  removeGrid()

jpeg("figures/vibe_sites.jpeg", width = 8, height = 1, units = "in", quality = 100, res = 300)
print(vibe_sites)
dev.off()

vibe_sites

# the final plot
vibe <- ggplot(vibmap, aes(x = Visit, y = Hour, fill = meanleq)) +
  geom_tile(color = "white", size = 0.1, na.rm = TRUE) + 
  scale_fill_viridis(name = "Hourly Amplitude (Leq)", option = "C") + 
  facet_grid(Sub_Mic ~ Site) +
  scale_y_continuous(trans = "reverse", breaks = unique(vibmap$Hour)) +
  theme_minimal(base_size = 8) +
  labs(x = "Visit Number (1-4)", y = "Hour of Day") +
  theme(legend.position = "bottom") +
  theme(plot.title = element_text(size = 14, color = "black", family = "sans")) +
  theme(axis.text.y = element_text(size = 6, color = "black", family = "sans")) +
  theme(strip.background = element_rect(colour = "white")) +
  theme(plot.title = element_text(hjust = 0, color = "black", family = "sans")) +
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_text(size = 6, color = "black", family = "sans")) +
  theme(legend.title = element_text(size = 8, color = "black", family = "sans")) +
  theme(legend.text = element_text(size = 6, color = "black", family = "sans")) +
  removeGrid()

jpeg("figures/vibe.jpeg", width = 8, height = 8, units = "in", quality = 100, res = 300)
print(vibe)
dev.off()

vibe
```

# Spatial Variation in Vibratory Noise

Does vibratory noise vary over space? Let's first look at average Leq across sites. We will use all 23 sites.

```{r leq_map, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}
leq_map <- ggmap(map) + 
  ggsn::scalebar(x.min = -96.9, x.max = -96.5, y.min = 40.57, y.max = 40.899,
           dist = 5, dist_unit = "km", transform = TRUE, location = "bottomleft", 
           st.bottom = FALSE, box.color = c("black", "black"), st.size = 4, border.size = 0.5, 
           st.dist = 0.03) + # add scalebar
  geom_polygon(data = lincoln, aes(x = longitude, y = latitude), fill = "slategray", alpha = 0.25, color = "gray30") +
  geom_point(data = sites, mapping = aes(x = Longitude, y = Latitude), pch=21, size = 1, fill = "black") +
  geom_label_repel(aes(x =Longitude, y = Latitude, fill = mean_leq, label = mean_leq), min.segment.length = 0.1, max.overlaps = Inf, size = 2, data = sites) +
  scale_fill_viridis(name = "Amplitude \n(Leq, dB)", option = "C") +
  ylab("Latitude") + xlab("Longitude") +
  labs(fill = "Avg. Leq (dB)") +
  theme_classic() + 
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
  theme(legend.position = c(0.75, 0.07),
        legend.direction = "horizontal",
        legend.background = element_rect(fill = "white",
                                  size = 0.5, linetype = "solid", 
                                  colour ="black"),
        
        legend.key.height = unit(0.15, 'cm'),
        legend.key.width = unit(0.4, 'cm')) + # legend properties
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 6, family = "sans"),
        legend.title = element_text(size = 6, family = "sans")) # text size

jpeg("figures/leq_map.jpeg", width = 4, height = 4.5, units = "in", quality = 100, res = 300)
print(leq_map)
dev.off()

leq_map

leq_map_med <- ggmap(map) + 
  ggsn::scalebar(x.min = -96.9, x.max = -96.5, y.min = 40.57, y.max = 40.899,
           dist = 5, dist_unit = "km", transform = TRUE, location = "bottomleft", 
           st.bottom = FALSE, box.color = c("black", "black"), st.size = 4, border.size = 0.5, 
           st.dist = 0.03) + # add scalebar
  geom_polygon(data = lincoln, aes(x = longitude, y = latitude), fill = "slategray", alpha = 0.25, color = "gray30") +
  geom_point(data = sites, mapping = aes(x = Longitude, y = Latitude), pch=21, size = 1, fill = "black") +
  geom_label_repel(aes(x =Longitude, y = Latitude, fill = med_leq, label = med_leq), min.segment.length = 0.1, max.overlaps = Inf, size = 2, data = sites) +
  scale_fill_viridis(name = "Leq", option = "C") +
  ylab("Latitude") + xlab("Longitude") +
  labs(fill = "Avg. Leq (dB)") +
  theme_classic() + 
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
  theme(legend.position = c(0.77, 0.07),
        legend.direction = "horizontal",
        legend.background = element_rect(fill = "white",
                                  size = 0.5, linetype = "solid", 
                                  colour ="black"),
        
        legend.key.height = unit(0.15, 'cm'),
        legend.key.width = unit(0.4, 'cm')) + # legend properties
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 6, family = "sans"),
        legend.title = element_text(size = 6, family = "sans")) # text size

jpeg("figures/leq_map_med.jpeg", width = 4, height = 4.5, units = "in", quality = 100, res = 300)
print(leq_map_med)
dev.off()

leq_map_med
```

Site averages vary from -55 dB to -70 dB (~15 dB difference). The sites with the highest Leq appear to occur near highly traveled roads (i.e., highways/interstates). 

Let's test this hypothesis by using the PCA analysis that reduced measures of potential traffic impact and see if that predicts vibratory noise levels. 

Let's first take a look at the raw data:

```{r spatial_rawplot, echo = FALSE, warning = FALSE, message = FALSE}
# let's look at the plot before stats
#Dim.1
dayavgl %>% 
  group_by(Dim.1, Substrate, Category) %>% 
  summarize(med = median(mean_leq),
            quantile.05 = quantile(mean_leq, 0.05),
            quantile.95 = quantile(mean_leq, 0.95)) %>% 
    mutate(Category = fct_relevel(Category, "Rural", "Urban")) %>% 
ggplot(aes(x = Dim.1, y = med, color = Substrate, fill = Substrate)) +
  geom_line() +
  geom_ribbon(aes(ymin = quantile.05, ymax = quantile.95), alpha = 0.5) +
  ggtitle("Raw Data") +
  xlab("Principal Component 1 (70.9%)") +
  ylab("Daily Average Leq (20-1000 Hz)") +
  scale_color_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_fill_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  theme_classic() +
  facet_wrap(~Category, scales = "free")

dayavgl %>% 
ggplot(aes(x = Dim.1, y = mean_leq, color = Substrate, fill = Substrate)) +
  geom_smooth(method = "loess") +
  ggtitle("Raw Data") +
  xlab("Principal Component 1 (70.9%)") +
  ylab("Daily Average Leq (20-1000 Hz)") +
  scale_color_manual("Substrate", values = c("grey30", "#66A61E"),
                        labels = c("Manmade", "Plant")) +
  scale_fill_manual("Substrate", values = c("grey30", "#66A61E"),
                       labels = c("Manmade", "Plant")) +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  theme_classic() +
  facet_wrap(~Category, scales = "free")

#Dim.2
dayavgl %>% 
  group_by(Dim.2, Substrate, Category) %>% 
  summarize(med = median(mean_leq),
            quantile.05 = quantile(mean_leq, 0.05),
            quantile.95 = quantile(mean_leq, 0.95)) %>% 
ggplot(aes(x = Dim.2, y = med, color = Substrate, fill = Substrate)) +
  geom_line() +
  geom_ribbon(aes(ymin = quantile.05, ymax = quantile.95), alpha = 0.5) +
  ggtitle("Raw Data") +
  xlab("Principal Component 1 (18.3%)") +
  ylab("Daily Average Leq (20-1000 Hz)") +
  scale_color_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_fill_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  theme_classic() +
  facet_wrap(~Category, scales = "free")

dayavgl %>% 
ggplot(aes(x = Dim.2, y = mean_leq, color = Substrate, fill = Substrate)) +
  geom_smooth(method = "loess") +
  ggtitle("Raw Data") +
  xlab("Principal Component 2 (18.3%)") +
  ylab("Daily Average Leq (20-1000 Hz)") +
  scale_color_manual("Substrate", values = c("grey30", "#66A61E"),
                        labels = c("Manmade", "Plant")) +
  scale_fill_manual("Substrate", values = c("grey30", "#66A61E"),
                       labels = c("Manmade", "Plant")) +
  scale_y_continuous(limits = c(-75, -49), breaks = c(-75, -70, -65, -60, -55, -50)) +
  theme_classic() +
  facet_wrap(~Category, scales = "free")
```

```{r spatial_lmer, echo = FALSE, warning = FALSE, message = FALSE}
# First let's look to see if there is a difference by our determined categories
#lmer
dayavgl.lmer.cat <- lmer(mean_leq ~ Category + (1|Site), data = dayavgl)
dayavgl.lmer.cat.stats <- summary(dayavgl.lmer.cat)
#dayavgl.lmer.cat.stats2 <- car::Anova(dayavgl.lmer.cat)
var.fix <- get_variance_fixed(dayavgl.lmer.cat)
var.ran <- get_variance_random(dayavgl.lmer.cat)
var.res <- get_variance_residual(dayavgl.lmer.cat)
R2m.cat = var.fix / (var.fix + var.ran + var.res)
R2c.cat = (var.fix + var.ran) / (var.fix + var.ran + var.res)

#robust lmer
dayavgl.rlmer.cat <- rlmer(mean_leq ~ Category + (1|Site), data = dayavgl)
dayavgl.rlmer.cat.stats <- summary(dayavgl.rlmer.cat)
coefs.robust.cat <- data.frame(coef(dayavgl.rlmer.cat.stats))
coefs.robust.cat$P <- round(2*pt(abs(coefs.robust.cat[,3]), dayavgl.lmer.cat.stats$devcomp$dims[4], lower=FALSE), 10)
var.fix <- get_variance_fixed(dayavgl.rlmer.cat)
var.ran <- get_variance_random(dayavgl.rlmer.cat)
var.res <- get_variance_residual(dayavgl.rlmer.cat)
R2mr.cat = var.fix / (var.fix + var.ran + var.res)
R2cr.cat = (var.fix + var.ran) / (var.fix + var.ran + var.res)
#similar results


# Let's look for overall effects of PC1 and substrate
#lmer
dayavgl.lmer <- lmer(mean_leq ~ Dim.1 * Substrate + (1|Site), data = dayavgl)
dayavgl.lmer.stats <- summary(dayavgl.lmer)
#dayavgl.lmer.stats2 <- car::Anova(dayavgl.lmer)
var.fix <- get_variance_fixed(dayavgl.lmer)
var.ran <- get_variance_random(dayavgl.lmer)
var.res <- get_variance_residual(dayavgl.lmer)
R2m = var.fix / (var.fix + var.ran + var.res)
R2c = (var.fix + var.ran) / (var.fix + var.ran + var.res)

#robust lmer
dayavgl.rlmer <- rlmer(mean_leq ~ Dim.1 * Substrate + (1|Site), data = dayavgl)
dayavgl.rlmer.stats <- summary(dayavgl.rlmer)
coefs.robust <- data.frame(coef(summary(dayavgl.rlmer)))
coefs.robust$P <- round(2*pt(abs(coefs.robust[,3]), dayavgl.lmer.stats$devcomp$dims[4], lower=FALSE), 10)
var.fix <- get_variance_fixed(dayavgl.rlmer)
var.ran <- get_variance_random(dayavgl.rlmer)
var.res <- get_variance_residual(dayavgl.rlmer)
R2mr = var.fix / (var.fix + var.ran + var.res)
R2cr = (var.fix + var.ran) / (var.fix + var.ran + var.res)
# similar results

# Now let's repeat this test looking only at rural data
#lmer
dayavgl_rural <- dayavgl %>% 
  filter(Category == "Rural")
dayavgl.lmer.r <- lmer(mean_leq ~ Dim.1 * Substrate + (1|Site), data = dayavgl_rural)
dayavgl.lmer.r.stats <- summary(dayavgl.lmer.r)
var.fix <- get_variance_fixed(dayavgl.lmer.r)
var.ran <- get_variance_random(dayavgl.lmer.r)
var.res <- get_variance_residual(dayavgl.lmer.r)
R2m.r = var.fix / (var.fix + var.ran + var.res)
R2c.r = (var.fix + var.ran) / (var.fix + var.ran + var.res)

#robust lmer
dayavgl.rlmer.r <- rlmer(mean_leq ~ Dim.1 * Substrate + (1|Site), data = dayavgl_rural)
dayavgl.rlmer.r.stats <- summary(dayavgl.rlmer.r)
coefs.robust.r <- data.frame(coef(summary(dayavgl.rlmer.r)))
coefs.robust.r$P <- round(2*pt(abs(coefs.robust.r[,3]), dayavgl.lmer.r.stats$devcomp$dims[4], lower=FALSE), 10)
var.fix <- get_variance_fixed(dayavgl.rlmer.r)
var.ran <- get_variance_random(dayavgl.rlmer.r)
var.res <- get_variance_residual(dayavgl.rlmer.r)
R2mr.r = var.fix / (var.fix + var.ran + var.res)
R2cr.r = (var.fix + var.ran) / (var.fix + var.ran + var.res)
# different results

# Now let's repeat this test looking only at urban data
#lmer
dayavgl_urban <- dayavgl %>% 
  filter(Category == "Urban")
dayavgl.lmer.u <- lmer(mean_leq ~ Dim.1 * Substrate + (1|Site), data = dayavgl_urban)
dayavgl.lmer.u.stats <- summary(dayavgl.lmer.u)
dayavgl.lmer.u.stats2 <- car::Anova(dayavgl.lmer.u)
var.fix <- get_variance_fixed(dayavgl.lmer.u)
var.ran <- get_variance_random(dayavgl.lmer.u)
var.res <- get_variance_residual(dayavgl.lmer.u)
R2m.u = var.fix / (var.fix + var.ran + var.res)
R2c.u = (var.fix + var.ran) / (var.fix + var.ran + var.res)

#robust lmer
dayavgl.rlmer.u <- rlmer(mean_leq ~ Dim.1 * Substrate + (1|Site), data = dayavgl_urban)
dayavgl.rlmer.u.stats <- summary(dayavgl.rlmer.u)
coefs.robust.u <- data.frame(coef(summary(dayavgl.rlmer.u)))
coefs.robust.u$P <- round(2*pt(abs(coefs.robust.u[,3]), dayavgl.lmer.u.stats$devcomp$dims[4], lower=FALSE), 10)
var.fix <- get_variance_fixed(dayavgl.rlmer.u)
var.ran <- get_variance_random(dayavgl.rlmer.u)
var.res <- get_variance_residual(dayavgl.rlmer.u)
R2mr.u = var.fix / (var.fix + var.ran + var.res)
R2cr.u = (var.fix + var.ran) / (var.fix + var.ran + var.res)
#similar results

# Let's look for overall effects of PC2 and substrate
#lmer
dayavgl.lmer2 <- lmer(mean_leq ~ Dim.2 * Substrate * Category + (1|Site), data = dayavgl)
#drop1(dayavgl.lmer2, test = "Chisq")
dayavgl.lmer2_2 <- update(dayavgl.lmer2, .~. -Dim.2:Substrate:Category)
#drop1(dayavgl.lmer2_2, test = "Chisq")
dayavgl.lmer2_3 <- update(dayavgl.lmer2_2, .~. -Dim.2:Substrate)
#drop1(dayavgl.lmer2_3, test = "Chisq")
dayavgl.lmer2_4 <- update(dayavgl.lmer2_3, .~. -Substrate:Category)
#drop1(dayavgl.lmer2_4, test = "Chisq")
dayavgl.lmer2.stats <- summary(dayavgl.lmer2_4)
dayavgl.lmer2.stats2 <- car::Anova(dayavgl.lmer2_4)
var.fix <- get_variance_fixed(dayavgl.lmer2_4)
var.ran <- get_variance_random(dayavgl.lmer2_4)
var.res <- get_variance_residual(dayavgl.lmer2_4)
R2m2 = var.fix / (var.fix + var.ran + var.res)
R2c2 = (var.fix + var.ran) / (var.fix + var.ran + var.res)

#robust
dayavgl.rlmer2 <- rlmer(mean_leq ~ Dim.2 + Substrate + Category + Dim.2:Category + (1|Site), data = dayavgl)
dayavgl.rlmer2.stats <- summary(dayavgl.rlmer2)
coefs.robust2 <- data.frame(coef(summary(dayavgl.rlmer2)))
coefs.robust2$P <- round(2*pt(abs(coefs.robust2[,3]), dayavgl.lmer2.stats$devcomp$dims[4], lower=FALSE), 10)
var.fix <- get_variance_fixed(dayavgl.rlmer2)
var.ran <- get_variance_random(dayavgl.rlmer2)
var.res <- get_variance_residual(dayavgl.rlmer2)
R2mr2 = var.fix / (var.fix + var.ran + var.res)
R2cr2 = (var.fix + var.ran) / (var.fix + var.ran + var.res)
#similar results
```

We performed `r paste(dayavgl.lmer.stats$call[1], "(", dayavgl.lmer.stats$call[2], ", data = ", dayavgl.lmer.stats$call[3], ")")` overall and for category subsets. We also tested each with `r dayavgl.rlmer.stats$call[1]`. If `r dayavgl.lmer.stats$call[1]` gave the same results as `r dayavgl.rlmer.stats$call[1]`, we used `r dayavgl.lmer.stats$call[1]`. Otherwise, we used `r dayavgl.rlmer.stats$call[1]`. We found:

```{r spatial_table, echo = FALSE, warning = FALSE, message = FALSE}
print("lmer results")
kable(data.frame(coef(summary(dayavgl.lmer.cat))))
kable(data.frame(coef(dayavgl.lmer.stats)))
kable(data.frame(coef(dayavgl.lmer.r.stats)))
kable(data.frame(coef(dayavgl.lmer.u.stats)))
kable(data.frame(coef(dayavgl.lmer2.stats)))

print("rlmer results")
kable(data.frame(coefs.robust.cat))
kable(data.frame(coefs.robust))
kable(data.frame(coefs.robust.r))
kable(data.frame(coefs.robust.u))
kable(data.frame(coefs.robust2))
```

Let's check the assumptions: 

```{r spatial_assumptions, echo = FALSE, warning = FALSE, message = FALSE}
#overall
test_dayavgl <- augment(dayavgl.lmer, data = dayavgl)
resid_dayavgl <- ggplot(test_dayavgl, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_dayavgl$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_dayavgl <- ggplot(test_dayavgl, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

cd<-data.frame(cooks.distance(dayavgl.lmer)) 
cd$num <- seq(1, nrow(cd), 1)
colnames(cd) <- c("Cooksd", "Num")
lev<-data.frame(hat(model.matrix(dayavgl.lmer)))
lev$num <- seq(1, nrow(lev), 1)
colnames(lev) <- c("Leverage", "Num")
data_dayavgl <- full_join(cd, lev, by = "Num")
lev_dayavgl <- data_dayavgl %>% 
  pivot_longer(cols = c(Leverage, Cooksd), names_to = "Variable", values_to = "Value") %>% 
  ggplot(aes(x = Num, y = Value, color = Variable)) +
  geom_hline(yintercept = 4/295) +
  geom_point() +
  theme_classic() +
  theme(legend.position = c(0.25, 0.75))

hist_dayavgl <- data.frame(ranef = ranef(dayavgl.lmer))
hist_dayavgl2<-hist_dayavgl[order(hist_dayavgl$ranef.condval),]
ran_ef_dayavgl <- hist_dayavgl2 %>% 
  ggplot(aes(y = ranef.grp, x = ranef.condval)) +
  geom_point() +
  geom_vline(xintercept = 0) +
  geom_linerange(aes(xmin = ranef.condval - 1.96 * ranef.condsd, xmax = ranef.condval + 1.96 * ranef.condsd)) +
  theme_classic() +
  xlab("Value of the Conditional Mean") +
  ylab("Site")


annotate_figure(ggarrange(resid_dayavgl, qq_dayavgl, lev_dayavgl, ran_ef_dayavgl,
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2), top = text_grob("Overall lmer PC1"))

plot(dayavgl.rlmer)

#rural
test_dayavgl <- augment(dayavgl.lmer.r, data = dayavgl_rural)
resid_dayavgl <- ggplot(test_dayavgl, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_dayavgl$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_dayavgl <- ggplot(test_dayavgl, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

cd<-data.frame(cooks.distance(dayavgl.lmer.r)) 
cd$num <- seq(1, nrow(cd), 1)
colnames(cd) <- c("Cooksd", "Num")
lev<-data.frame(hat(model.matrix(dayavgl.lmer.r)))
lev$num <- seq(1, nrow(lev), 1)
colnames(lev) <- c("Leverage", "Num")
data_dayavgl <- full_join(cd, lev, by = "Num")
lev_dayavgl <- data_dayavgl %>% 
  pivot_longer(cols = c(Leverage, Cooksd), names_to = "Variable", values_to = "Value") %>% 
  ggplot(aes(x = Num, y = Value, color = Variable)) +
  geom_hline(yintercept = 4/78) +
  geom_point() +
  theme_classic() +
  theme(legend.position = c(0.25, 0.75))

hist_dayavgl <- data.frame(ranef = ranef(dayavgl.lmer.r))
hist_dayavgl2<-hist_dayavgl[order(hist_dayavgl$ranef.condval),]
ran_ef_dayavgl <- hist_dayavgl2 %>% 
  ggplot(aes(y = ranef.grp, x = ranef.condval)) +
  geom_point() +
  geom_vline(xintercept = 0) +
  geom_linerange(aes(xmin = ranef.condval - 1.96 * ranef.condsd, xmax = ranef.condval + 1.96 * ranef.condsd)) +
  theme_classic() +
  xlab("Value of the Conditional Mean") +
  ylab("Site")

annotate_figure(ggarrange(resid_dayavgl, qq_dayavgl, lev_dayavgl, ran_ef_dayavgl,
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2), top = text_grob("Rural lmer PC1"))

plot(dayavgl.rlmer.r)

#urban
test_dayavgl <- augment(dayavgl.lmer.u, data = dayavgl_urban)
resid_dayavgl <- ggplot(test_dayavgl, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_dayavgl$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_dayavgl <- ggplot(test_dayavgl, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

cd<-data.frame(cooks.distance(dayavgl.lmer.u)) 
cd$num <- seq(1, nrow(cd), 1)
colnames(cd) <- c("Cooksd", "Num")
lev<-data.frame(hat(model.matrix(dayavgl.lmer.u)))
lev$num <- seq(1, nrow(lev), 1)
colnames(lev) <- c("Leverage", "Num")
data_dayavgl <- full_join(cd, lev, by = "Num")
lev_dayavgl <- data_dayavgl %>% 
  pivot_longer(cols = c(Leverage, Cooksd), names_to = "Variable", values_to = "Value") %>% 
  ggplot(aes(x = Num, y = Value, color = Variable)) +
  geom_hline(yintercept = 4/217) +
  geom_point() +
  theme_classic() +
  theme(legend.position = c(0.25, 0.75))

hist_dayavgl <- data.frame(ranef = ranef(dayavgl.lmer.u))
hist_dayavgl2<-hist_dayavgl[order(hist_dayavgl$ranef.condval),]
ran_ef_dayavgl <- hist_dayavgl2 %>% 
  ggplot(aes(y = ranef.grp, x = ranef.condval)) +
  geom_point() +
  geom_vline(xintercept = 0) +
  geom_linerange(aes(xmin = ranef.condval - 1.96 * ranef.condsd, xmax = ranef.condval + 1.96 * ranef.condsd)) +
  theme_classic() +
  xlab("Value of the Conditional Mean") +
  ylab("Site")

annotate_figure(ggarrange(resid_dayavgl, qq_dayavgl, lev_dayavgl, ran_ef_dayavgl,
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2), top = text_grob("Urban lmer PC1"))

plot(dayavgl.rlmer.u)

```

Let's graph the results:

```{r spatial_graph, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}
predictions2 <- expand.grid(Category = levels(factor(dayavgl$Category)))
predictions2$response <- predict(dayavgl.lmer.cat, newdata = predictions2, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions2, re.form = ~0, type = "response")
}
#bigBoot_space_cat <- bootMer(dayavgl.lmer.cat, myFunc, nsim = 1000)
#saveRDS(bigBoot_space_cat, file = "data/bigBoot_space_cat.Rds")
bigBoot_space_cat <- readRDS("data/bigBoot_space_cat.Rds")
predSE <- t(apply(bigBoot_space_cat$t, MARGIN = 2, FUN = sd))
predictions2$SE <- predSE[1, ]


spatial_dayavgl <- dayavgl %>% 
  ungroup() %>% 
  dplyr::select(Site, Category, Substrate, Dim.1, Dim.2, mean_leq) %>% 
  group_by(Site, Substrate, Category, Dim.1, Dim.2) %>% 
  summarize(mean = mean(mean_leq),
            sd = sd(mean_leq))

predictions <- expand.grid(Dim.1 = seq(-3.5, 2.5, 0.05),
                           Substrate = levels(factor(dayavgl$Substrate)))
predictions$response <- predict(dayavgl.lmer, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_space <- bootMer(dayavgl.lmer, myFunc, nsim = 1000)
#saveRDS(bigBoot_space, file = "data/bigBoot_space.Rds")
bigBoot_space <- readRDS("data/bigBoot_space.Rds")
predSE <- t(apply(bigBoot_space$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

#nd = expand.grid(Dim.1 = seq(-3.5, 2.5, 0.05), Substrate = levels(factor(dayavgl$Substrate)))
#predictions <- augment(dayavgl.lm, newdata = nd, re.form = NA, se_fit = TRUE, type = "response")

space <- ggplot() +
  annotate("rect", xmin = -3.75, xmax = -1.5, ymin = -73, ymax = -57,
           alpha = 0.25, color = "#1B9E77", fill = NA, linewidth = 1) +
  annotate("rect", xmin = -0.5, xmax = 2.5, ymin = -69, ymax = -50,
           alpha = 0.25, color = "#D95F02", fill = NA, linewidth = 1) +
  geom_point(aes(x = Dim.1, y = mean, color = Substrate), data = spatial_dayavgl, position = position_dodge(width = 0.25), size = 1) +
  geom_errorbar(aes(x = Dim.1, ymax = mean + sd, ymin = mean - sd, color = Substrate), width = 0, data = spatial_dayavgl, position = position_dodge(width = 0.25), linewidth = 0.4) +
  geom_point(aes(x = Dim.1, y = mean_leq), color = "red", data = highlights) +
  geom_line(aes(x = Dim.1, y = response, color = Substrate), data = predictions) +
  geom_ribbon(aes(x = Dim.1, ymax = response + SE, ymin = response - SE, fill = Substrate, color = Substrate), data = predictions, alpha = 0.5) +
  geom_label_repel(aes(x = Dim.1, y = mean_leq, label = mean_leq), color = "red", hjust = "right", data = highlights, size = 2) +
  xlab("Potential traffic impact \n(PC1, explains 70.9%)") +
  ylab("Daily average relative amplitude \n(Leq in dB re FS, 20-1000 Hz)") +
  scale_color_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_fill_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  scale_x_continuous(limits = c(-3.75, 2.65), breaks = c(-3, -2, -1, 0, 1, 2)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        axis.title = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 8, color = "black", family = "sans"),
        legend.position = "top",
        legend.title = element_text(size = 8),
        panel.grid.major.y = element_line(colour = "black", linetype = "dashed", linewidth = 0.1))

jpeg("figures/spatial.jpeg", width = 2.75, height = 4.5, units = "in", quality = 100, res = 300)
print(space)
dev.off()

space

spatial_dayavgl_u <- spatial_dayavgl %>% 
  filter(Category == "Urban")

predictions <- expand.grid(Dim.1 = seq(0, 2.2, 0.05),
                           Substrate = levels(factor(dayavgl_urban$Substrate)))
predictions$response <- predict(dayavgl.lmer.u, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_space_urban <- bootMer(dayavgl.lmer.u, myFunc, nsim = 1000)
#saveRDS(bigBoot_space_urban, file = "data/bigBoot_space_urban.Rds")
bigBoot_space_urban <- readRDS("data/bigBoot_space_urban.Rds")
predSE <- t(apply(bigBoot_space_urban$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

#nd = expand.grid(Dim.1 = seq(-3.5, 2.5, 0.05), Substrate = levels(factor(dayavgl$Substrate)))
#predictions <- augment(dayavgl.lm, newdata = nd, re.form = NA, se_fit = TRUE, type = "response")

space_urban <- ggplot() +
  geom_point(aes(x = Dim.1, y = mean, color = Substrate), data = spatial_dayavgl_u, position = position_dodge(width = 0.25), size = 1) +
  geom_errorbar(aes(x = Dim.1, ymax = mean + sd, ymin = mean - sd, color = Substrate), width = 0, data = spatial_dayavgl_u, position = position_dodge(width = 0.25), linewidth = 0.4) +
  geom_line(aes(x = Dim.1, y = response, color = Substrate), data = predictions) +
  geom_ribbon(aes(x = Dim.1, ymax = response + SE, ymin = response - SE, fill = Substrate, color = Substrate), data = predictions, alpha = 0.5) +
  xlab("Potential traffic impact \n(PC1, explains 70.9%)") +
  ylab("Daily average relative amplitude \n(Leq in dB re FS, 20-1000 Hz)") +
  scale_color_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_fill_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_y_continuous(limits = c(-75, -49), breaks = c(-75, -70, -65, -60, -55, -50)) +
  scale_x_continuous(limits = c(0, 2.2), breaks = c(0, 0.5, 1, 1.5, 2)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        axis.title = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 8, color = "black", family = "sans"),
        legend.position = "none",
        legend.title = element_text(size = 8),
        panel.grid.major.y = element_line(colour = "black", linetype = "dashed", linewidth = 0.1),
        panel.border = element_rect(color = "#D95F02", fill = NA, linewidth = 2))

jpeg("figures/spatial_urban.jpeg", 3.25, height = 2.75, units = "in", quality = 100, res = 300)
print(space_urban)
dev.off()

space_urban

spatial_dayavgl_r <- spatial_dayavgl %>% 
  filter(Category == "Rural")

predictions <- expand.grid(Dim.1 = seq(-3.4, -2, 0.05),
                           Substrate = levels(factor(dayavgl_rural$Substrate)))
predictions$response <- predict(dayavgl.lmer.r, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_space_rural <- bootMer(dayavgl.lmer.r, myFunc, nsim = 1000)
#saveRDS(bigBoot_space_rural, file = "data/bigBoot_space_rural.Rds")
bigBoot_space_rural <- readRDS("data/bigBoot_space_rural.Rds")
predSE <- t(apply(bigBoot_space_rural$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

#nd = expand.grid(Dim.1 = seq(-3.5, 2.5, 0.05), Substrate = levels(factor(dayavgl$Substrate)))
#predictions <- augment(dayavgl.lm, newdata = nd, re.form = NA, se_fit = TRUE, type = "response")

space_rural <- ggplot() +
  geom_point(aes(x = Dim.1, y = mean, color = Substrate), data = spatial_dayavgl_r, position = position_dodge(width = 0.25), size = 1) +
  geom_errorbar(aes(x = Dim.1, ymax = mean + sd, ymin = mean - sd, color = Substrate), width = 0, data = spatial_dayavgl_r, position = position_dodge(width = 0.25), linewidth = 0.4) +
  geom_line(aes(x = Dim.1, y = response, color = Substrate), data = predictions) +
  geom_ribbon(aes(x = Dim.1, ymax = response + SE, ymin = response - SE, fill = Substrate, color = Substrate), data = predictions, alpha = 0.5) +
  xlab("Potential traffic impact \n(PC1, explains 70.9%)") +
  ylab("Daily average relative amplitude \n(Leq in dB re FS, 20-1000 Hz)") +
  scale_color_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_fill_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  scale_x_continuous(limits = c(-3.5, -2), breaks = c(-3.5, -3, -2.5, -2)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        axis.title = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 8, color = "black", family = "sans"),
        legend.position = "none",
        legend.title = element_text(size = 8),
        panel.grid.major.y = element_line(colour = "black", linetype = "dashed", linewidth = 0.1),
        panel.border = element_rect(color = "#1B9E77", fill = NA, linewidth = 2))

jpeg("figures/spatial_rural.jpeg", 3.25, height = 2.75, units = "in", quality = 100, res = 300)
print(space_rural)
dev.off()

space_rural

predictions <- as.data.frame(effect("Dim.1*Substrate", dayavgl.rlmer.r))

space_rural_robust <- ggplot() +
  geom_point(aes(x = Dim.1, y = mean, color = Substrate), data = spatial_dayavgl_r, position = position_dodge(width = 0.25), size = 1) +
  geom_errorbar(aes(x = Dim.1, ymax = mean + sd, ymin = mean - sd, color = Substrate), width = 0, data = spatial_dayavgl_r, position = position_dodge(width = 0.25), linewidth = 0.4) +
  geom_line(aes(x = Dim.1, y = fit, color = Substrate), data = predictions) +
  geom_ribbon(aes(x = Dim.1, ymax = fit + se, ymin = fit - se, fill = Substrate, color = Substrate), data = predictions, alpha = 0.5) +
  xlab("Potential traffic impact \n(PC1, explains 70.9%)") +
  ylab("Daily average relative amplitude \n(Leq in dB re FS, 20-1000 Hz)") +
  scale_color_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_fill_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  scale_x_continuous(limits = c(-3.5, -2), breaks = c(-3.5, -3, -2.5, -2)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        axis.title = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 8, color = "black", family = "sans"),
        legend.position = "none",
        legend.title = element_text(size = 8),
        panel.grid.major.y = element_line(colour = "black", linetype = "dashed", linewidth = 0.1),
        panel.border = element_rect(color = "#1B9E77", fill = NA, linewidth = 2))

jpeg("figures/space_rural_robust.jpeg", 3.25, height = 2.75, units = "in", quality = 100, res = 300)
print(space_rural_robust)
dev.off()

space_rural_robust


predictions <- expand.grid(Dim.2 = seq(-2, 2, 0.05),
                           Substrate = levels(factor(dayavgl$Substrate)),
                           Category = levels(factor(dayavgl$Category)))
predictions$response <- predict(dayavgl.lmer2, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_space2 <- bootMer(dayavgl.lmer2, myFunc, nsim = 1000)
#saveRDS(bigBoot_space2, file = "data/bigBoot_space2.Rds")
bigBoot_space2 <- readRDS("data/bigBoot_space2.Rds")
predSE <- t(apply(bigBoot_space2$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

#nd = expand.grid(Dim.1 = seq(-3.5, 2.5, 0.05), Substrate = levels(factor(dayavgl$Substrate)))
#predictions <- augment(dayavgl.lm, newdata = nd, re.form = NA, se_fit = TRUE, type = "response")

space2 <- ggplot() +
  geom_point(aes(x = Dim.2, y = mean, color = Substrate), data = spatial_dayavgl, position = position_dodge(width = 0.25), size = 1) +
  geom_errorbar(aes(x = Dim.2, ymax = mean + sd, ymin = mean - sd, color = Substrate), width = 0, data = spatial_dayavgl, position = position_dodge(width = 0.25), linewidth = 0.4) +
  geom_point(aes(x = Dim.2, y = mean_leq), color = "red", data = highlights) +
  geom_line(aes(x = Dim.2, y = response, color = Substrate), data = predictions) +
  geom_ribbon(aes(x = Dim.2, ymax = response + SE, ymin = response - SE, fill = Substrate, color = Substrate), data = predictions, alpha = 0.5) +
  geom_label_repel(aes(x = Dim.2, y = mean_leq, label = mean_leq), color = "red", hjust = "right", data = highlights, size = 2) +
  xlab("Potential traffic impact (PC2, explains 18.3%)") +
  ylab("Daily average relative amplitude \n(Leq in dB re FS, 20-1000 Hz)") +
  scale_color_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_fill_manual("Substrate", values = c("grey30", "#66A61E"),
                     labels = c("Manmade", "Plant")) +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  scale_x_continuous(limits = c(-2, 2), breaks = c(-2, -1, 0, 1, 2)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        axis.title = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 8, color = "black", family = "sans"),
        legend.position = "top",
        legend.title = element_text(size = 8),
        panel.grid.major.y = element_line(colour = "black", linetype = "dashed", linewidth = 0.1)) +
  facet_wrap(~Category)

jpeg("figures/spatial2.jpeg", width = 6.5, height = 4, units = "in", quality = 100, res = 300)
print(space2)
dev.off()

space2

pc2_stats <- data.frame(Noise_Var = c("Spatial", "Spatial", "Spatial", "Spatial"),
                        Data = c("Daily Average", "Daily Average", "Daily Average", "Daily Average"),
                        Variable = c("Potential Traffic Impact (PC2)", "Substrate", "Rural/Urban", "Potential Traffic Impact (PC2) x Rural/Urban"),
                        Chi = c(8.88, 35.47, 29.09, 3.39),
                        N = c(295, 295, 295, 295),
                        P = c("  0.003 **", "< 0.001 ***", "< 0.001 ***", "   0.065 ."),
                        Cond = c(0.81, 0.81, 0.81, 0.81),
                        Marg = c(0.53, 0.53, 0.53, 0.53))
colnames(pc2_stats) <- c('Noise Variation','Data (Subset by)','Variable', 'Chi-Squared', 'N', 'P-Value', 'Cond. R²', 'Marg. R²')

flextable(pc2_stats[ , 1:8]) %>% 
  autofit() %>% 
  merge_v(j = c('Noise Variation', 'Data (Subset by)', 'Cond. R²', 'Marg. R²'), part = "body") %>% 
  bold(bold = TRUE, part = "header") %>% 
  hline_bottom(part = "body", border = officer::fp_border(width = 2)) %>% 
  border(j = c('Noise Variation', 'Data (Subset by)', 'Cond. R²', 'Marg. R²'), border.bottom = officer::fp_border(width = 2)) %>% 
  fontsize(size = 10, part = "all") %>% 
  align(align = "center", part = "all") %>% 
  valign(valign = "top", part = "all") %>% 
  save_as_image(path = here::here("figures/pc2_stats_table.png"))
```

*By Category - lmer*

Urban sites had louder daily vibrations than rural sites (t = `r round(coef(dayavgl.lmer.cat.stats)[2, 4], 2)`, df = `r dayavgl.lmer.cat.stats$devcomp$dims[3]`, `r dayavgl.lmer.cat.stats$devcomp$dims[1]`, P `r ifelse(round(coef(dayavgl.lmer.cat.stats)[2,5], 3) == 0, print("< 0.001"), print(paste("=", round(coef(dayavgl.lmer.cat.stats)[2,5], 3))))`). 

*Overall PC1 - lmer* 

Daily average Leq has a significant positive relationship with Principal Component 1 - road vibratory noise (t = `r round(coef(dayavgl.lmer.stats)[2,4], 2)`, df = `r dayavgl.lmer.stats$devcomp$dims[3]`, `r dayavgl.lmer.stats$devcomp$dims[1]`, P `r ifelse(round(coef(dayavgl.lmer.stats)[2,5], 3) == 0, print("< 0.001"), print(paste("=", round(coef(dayavgl.lmer.stats)[2,5], 3))))`, cond R$^2$ = `r round(R2c, 2)`, marg R$^2$ = `r round(R2m, 2)`). Daily average Leq was significantly higher on manmade material than plant material (t = `r round(coef(dayavgl.lmer.stats)[3,4], 2)`, df = `r dayavgl.lmer.stats$devcomp$dims[3]`, `r dayavgl.lmer.stats$devcomp$dims[1]`, P `r ifelse(round(coef(dayavgl.lmer.stats)[3,5], 3) == 0, print("< 0.001"), print(paste("=", round(coef(dayavgl.lmer.stats)[3,5], 3))))`). There is no interaction (t = `r round(coef(dayavgl.lmer.stats)[4,4], 2)`, df = `r dayavgl.lmer.stats$devcomp$dims[3]`, `r dayavgl.lmer.stats$devcomp$dims[1]`, P `r ifelse(round(coef(dayavgl.lmer.stats)[4,5], 3) == 0, print("< 0.001"), print(paste("=", round(coef(dayavgl.lmer.stats)[4,5], 3))))`).

*Urban Subset - lmer*

Daily average Leq has a significant positive relationship with Principal Component 1 - road vibratory noise (t = `r round(coef(dayavgl.lmer.u.stats)[2,4], 2)`, df = `r dayavgl.lmer.u.stats$devcomp$dims[3]`, `r dayavgl.lmer.u.stats$devcomp$dims[1]`, P `r ifelse(round(coef(dayavgl.lmer.u.stats)[2,5], 3) == 0, print("< 0.001"), print(paste("=", round(coef(dayavgl.lmer.u.stats)[2,5], 3))))`, cond R$^2$ = `r round(R2c.u, 2)`, marg R$^2$ = `r round(R2m.u, 2)`). Daily average Leq was significantly higher on manmade material than plant material (t = `r round(coef(dayavgl.lmer.u.stats)[3,4], 2)`, df = `r dayavgl.lmer.u.stats$devcomp$dims[3]`, `r dayavgl.lmer.u.stats$devcomp$dims[1]`, P `r ifelse(round(coef(dayavgl.lmer.u.stats)[3,5], 3) == 0, print("< 0.001"), print(paste("=", round(coef(dayavgl.lmer.u.stats)[3,5], 3))))`). There is no interaction (t = `r round(coef(dayavgl.lmer.u.stats)[4,4], 2)`, df = `r dayavgl.lmer.u.stats$devcomp$dims[3]`, `r dayavgl.lmer.u.stats$devcomp$dims[1]`, P `r ifelse(round(coef(dayavgl.lmer.u.stats)[4,5], 3) == 0, print("< 0.001"), print(paste("=", round(coef(dayavgl.lmer.u.stats)[4,5], 3))))`).

*Rural Subset - rlmer*

There was no sigificant correlation between daily average Leq and Principal Component 1 - road vibratory noise (t = `r round(coefs.robust.r[2,3], 2)`, df = `r dayavgl.rlmer.r.stats$devcomp$dims[3]`, `r dayavgl.rlmer.r.stats$devcomp$dims[1]`, P `r ifelse(round(coefs.robust.r[2,4], 3) == 0, print("< 0.001"), print(paste("=", round(coefs.robust.r[2,4], 3))))`, cond R$^2$ = `r round(R2cr.r, 2)`, marg R$^2$ = `r round(R2mr.r, 2)`), substrate (t = `r round(coefs.robust.r[3,3], 2)`, df = `r dayavgl.rlmer.r.stats$devcomp$dims[3]`, `r dayavgl.rlmer.r.stats$devcomp$dims[1]`, P `r ifelse(round(coefs.robust.r[3,4], 3) == 0, print("< 0.001"), print(paste("=", round(coefs.robust.r[3,4], 3))))`), or interaction (t = `r round(coefs.robust.r[4,3], 2)`, df = `r dayavgl.rlmer.r.stats$devcomp$dims[3]`, `r dayavgl.rlmer.r.stats$devcomp$dims[1]`, P `r ifelse(round(coefs.robust.r[4,4], 3) == 0, print("< 0.001"), print(paste("=", round(coefs.robust.r[4,4], 3))))`).

*Overall PC2 - lmer*

Daily average Leq has a significant positive relationship with Principal Component 2 - road vibratory noise (Chisq = `r round(dayavgl.lmer2.stats2[1,1], 2)`, df = `r dayavgl.lmer2.stats$devcomp$dims[3]`, `r dayavgl.lmer2.stats$devcomp$dims[1]`, P `r ifelse(round(dayavgl.lmer2.stats2[1,3], 3) == 0, print("< 0.001"), print(paste("=", round(dayavgl.lmer2.stats2[1,3], 3))))`, cond R$^2$ = `r round(R2c2, 2)`, marg R$^2$ = `r round(R2m2, 2)`). Daily average Leq was significantly higher on manmade material than plant material (Chisq = `r round(dayavgl.lmer2.stats2[2,1], 2)`, df = `r dayavgl.lmer2.stats$devcomp$dims[3]`, `r dayavgl.lmer2.stats$devcomp$dims[1]`, P `r ifelse(round(dayavgl.lmer2.stats2[2,3], 3) == 0, print("< 0.001"), print(paste("=", round(dayavgl.lmer2.stats2[2,3], 3))))`). Urban sites had louder vibrations than rural sites (Chisq = `r round(dayavgl.lmer2.stats2[3,1], 2)`, df = `r dayavgl.lmer2.stats$devcomp$dims[3]`, `r dayavgl.lmer2.stats$devcomp$dims[1]`, P `r ifelse(round(dayavgl.lmer2.stats2[3,3], 3) == 0, print("< 0.001"), print(paste("=", round(dayavgl.lmer2.stats2[3,3], 3))))`). There is a trend of an interaction between PC2 and Category (Chisq = `r round(dayavgl.lmer2.stats2[4,1], 2)`, df = `r dayavgl.lmer2.stats$devcomp$dims[3]`, `r dayavgl.lmer2.stats$devcomp$dims[1]`, P `r ifelse(round(dayavgl.lmer2.stats2[4,3], 3) == 0, print("< 0.001"), print(paste("=", round(dayavgl.lmer2.stats2[4,3], 3))))`).

Let's take a closer look at the substrate.

Manmade structures - Paneling, Metal, Concrete, Brick, Wood

Plant structures - Herb, Tree, Shrub, Vine

```{r substrate, echo = FALSE, warning = FALSE, message = FALSE}
dayavgl <- dayavgl %>% 
  mutate(Type = ifelse(Material == "Bromus inermis" | 
                         Material == "Convallaria majalis" | 
                         Material == "Hosta" | 
                         Material == "Polygonatum biflorum" | 
                         Material == "Hosta plantaginea" | 
                         Material == "Hosta sieboldii" | 
                         Material == "Paeonia lactiflora" | 
                         Material == "???", 
                       "Herb",
                       ifelse(Material == "Juniperus virginiana" | 
                                Material == "Picea pungens", 
                              "Tree",
                       ifelse(Material == "Spirea cantoniensis" |
                                Material == "Taxus cuspidata" | 
                                Material == "Berberis thunbergii" | 
                                Material == "Rubus allegheniensis" | 
                                Material == "Syringa vulgaris" | 
                                Material == "Viburnum lantana" | 
                                Material == "Spiraea japonica" | 
                                Material == "Taxus canadensis", 
                              "Shrub",
                        ifelse(Material == "Euonymus fortunei" | 
                                 Material == "Parthenocissus tricuspidata" | 
                                 Material == "Glechoma hederacea", 
                               "Vine",
                        ifelse(Material == "Paneling", 
                               "Paneling", 
                        ifelse(Material == "Cement" | 
                                 Material == "Concrete", 
                               "Concrete", 
                        ifelse(Material == "Brick", 
                               "Brick", 
                        ifelse(Material == "Metal", 
                               "Metal",
                        ifelse(Material == "Wood", 
                                "Wood", "Missed"))))))))))

ggplot(aes(x = Dim.1, y = mean_leq, color = Type, group = Type), data = dayavgl) +
  #geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  scale_color_manual(values = c("red", "orange", "green", "yellow", "pink", "darkgreen", "blue", "purple", "lightblue"),
                     labels = c("Brick", "Concrete", "Herb", "Metal", "Paneling", "Shrub", "Tree", "Vine", "Wood")) +
  xlab("Principal Component 1 (74.7%)") +
  ylab("Average Daily Leq (20-1000 Hz)") +
  theme_classic() +
  theme(text = element_text(size = 10, color = "Black", family = "sans"))
```

Brick, paneling, and shrubs carried the highest amplitude vibrations Bricks and herbs have the steepest slopes, which might suggest these substrates are affected by vibratory noise. Wood in quiet areas have high vibrations, probably as a result of people and pets walking on porches. 

# Temporal Variation in Vibratory Noise

## Season

```{r season_visit_rawplot, echo = FALSE, warning = FALSE, message = FALSE}
# let's first check out the raw data
#dayavgl_20 %>%
#    group_by(Visit, Category) %>%
#     rstatix::identify_outliers(mean_leq)

#dayavgl_20 %>%
#  group_by(Visit, Category) %>%
#  shapiro_test(mean_leq)

dayavgl_20 %>% 
  mutate(Visit = fct_relevel(Visit, "1", "2", "3", "4")) %>% 
ggplot(aes(x = Visit, y = mean_leq, color = Category)) +
  geom_boxplot() +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  scale_color_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_fill_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  ylab("Daily Average Leq (20-1000 Hz)") +
  theme_classic()

dayavgl_20 %>% 
group_by(Visit, Category) %>% 
  summarize(mean = mean(mean_leq),
            se = plotrix::std.error(mean_leq)) %>% 
  mutate(Visit = fct_relevel(Visit, "1", "2", "3", "4")) %>% 
  ggplot(aes(x = Visit, y = mean, group = Category, color = Category, fill = Category)) +
  geom_point(size = 2) +
  geom_line() +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0.25) +
  scale_y_continuous(limits = c(-70, -60), breaks = c(-70, -65, -60)) +
  scale_color_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_fill_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  ylab("Daily Average Leq (20-1000 Hz)") +
  theme_classic()

dayavgl_20 %>% 
    mutate(Visit = fct_relevel(Visit, "1", "2", "3", "4")) %>% 
ggplot(aes(x = Visit, y = mean_leq)) +
  geom_boxplot() +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  ylab("Daily Average Leq (20-1000 Hz)") +
  theme_classic()
```

It seems like the rural sites got louder on the third visit. 

```{r season_visit_lmer, echo = FALSE, warning = FALSE, message = FALSE}
#lmer
season.lmer <- lmer(mean_leq ~ Visit * Category + (1|Site), data = dayavgl_20)
season.lmer.stats <- summary(season.lmer)
season.lmer.stats2 <- car::Anova(season.lmer, test.statistic = "Chisq")
var.fix <- get_variance_fixed(season.lmer)
var.ran <- get_variance_random(season.lmer)
var.res <- get_variance_residual(season.lmer)
R2m.s = var.fix / (var.fix + var.ran + var.res)
R2c.s = (var.fix + var.ran) / (var.fix + var.ran + var.res)

#robust lmer
dayavgl_20 <- dayavgl_20 %>% 
  mutate(Visit = fct_relevel(Visit, "3", "1", "2", "4"))
dayavgl_20 <- dayavgl_20 %>% 
  mutate(Visit2 = ifelse(Visit == "1" | Visit == "2", 1, 2))
season.rlmer <- rlmer(mean_leq ~ Visit * Category + (1|Site), data = dayavgl_20)
season.rlmer.stats <- summary(season.rlmer)
coefs.robustr.s <- data.frame(coef(season.rlmer.stats))
coefs.robustr.s$P <- round(2*pt(abs(coefs.robustr.s[,3]), season.rlmer.stats$devcomp$dims[4], lower=FALSE), 10)
var.fix <- get_variance_fixed(season.rlmer)
var.ran <- get_variance_random(season.rlmer)
var.res <- get_variance_residual(season.rlmer)
R2mr.s = var.fix / (var.fix + var.ran + var.res)
R2cr.s = (var.fix + var.ran) / (var.fix + var.ran + var.res)

#similar results
```

We performed `r paste(season.lmer.stats$call[1], "(", season.lmer.stats$call[2], ", data = ", season.lmer.stats$call[3], ")")` and as a `r season.rlmer.stats$call[1]` and found: 

```{r season_visit_table, echo = FALSE, warning = FALSE, message = FALSE}
kable(season.lmer.stats2)
emmeans(season.lmer, list(pairwise ~ Visit), adjust = "tukey")
emmeans(season.lmer, pairwise ~ Visit | Category, adjust = "tukey")
kable(coefs.robustr.s)
```

Let's check the assumptions: 

```{r season_visit_assump, echo = FALSE, warning = FALSE, message = FALSE}
test_season <- augment(season.lmer, data = dayavgl_20)
resid_season <- ggplot(test_season, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_season$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_season <- ggplot(test_season, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

cd<-data.frame(cooks.distance(season.lmer)) 
cd$num <- seq(1, nrow(cd), 1)
colnames(cd) <- c("Cooksd", "Num")
lev<-data.frame(hat(model.matrix(season.lmer)))
lev$num <- seq(1, nrow(lev), 1)
colnames(lev) <- c("Leverage", "Num")
data_season <- full_join(cd, lev, by = "Num")
lev_season <- data_season %>% 
  pivot_longer(cols = c(Leverage, Cooksd), names_to = "Variable", values_to = "Value") %>% 
  ggplot(aes(x = Num, y = Value, color = Variable)) +
  geom_hline(yintercept = 4/295) +
  geom_point() +
  theme_classic() +
  theme(legend.position = c(0.25, 0.75))

hist_season <- data.frame(ranef = ranef(season.lmer))
hist_season2<-hist_season[order(hist_season$ranef.condval),]
ran_ef_season <- hist_season2 %>% 
  ggplot(aes(y = ranef.grp, x = ranef.condval)) +
  geom_point() +
  geom_vline(xintercept = 0) +
  geom_linerange(aes(xmin = ranef.condval - 1.96 * ranef.condsd, xmax = ranef.condval + 1.96 * ranef.condsd)) +
  theme_classic() +
  xlab("Value of the Conditional Mean") +
  ylab("Site")


annotate_figure(ggarrange(resid_season, qq_season, lev_season, ran_ef_season,
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2), top = text_grob("Season lmer"))

plot(season.rlmer)
```

Let's graph the results:

```{r season_visit_graph, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}
predictions <- expand.grid(Visit = levels(factor(dayavgl$Visit)),
                           Category = levels(factor(dayavgl_20$Category)))
predictions$response <- predict(season.lmer, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_season <- bootMer(season.lmer, myFunc, nsim = 1000)
#saveRDS(bigBoot_season, file = "data/bigBoot_season.Rds")
bigBoot_season <- readRDS("data/bigBoot_season.Rds")
predSE <- t(apply(bigBoot_season$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

group2v3 <- data.frame(x = c(2, 3), 
                   y = c(-51, -51))

harvest_Lan <- readRDS("data/harvest_Lan.rds") 
harvest_mean <- harvest_Lan %>% 
  filter(Commodity == "MEAN") %>% 
  mutate(num = seq(5, 12, 1))
added <- data.frame(Week.Ending = c("2020-08-09", "2020-08-16", "2020-08-23", "2020-08-30"),
                    Commodity = "MEAN",
                    Value = 0, 
                    Weekly.Value = 0,
                    Crop = "Mean",
                    num = seq(1, 4, 1)) %>% 
  mutate(Week.Ending = ymd(Week.Ending))
mean_harvest <- rbind(harvest_mean, added)
mean_harvest <- mean_harvest %>% 
  arrange(num) %>% 
  mutate(Visit = seq(0, 3.96, 0.36))

dayavgl_20 <- dayavgl_20 %>% 
  mutate(Visit = fct_relevel(Visit, "1", "2", "3", "4"))

season_dayavgl_20 <- dayavgl_20 %>% 
  ungroup() %>% 
  dplyr::select(Site, Visit, Category, mean_leq) %>% 
  group_by(Category, Visit) %>% 
  summarise(mean = mean(mean_leq),
            sd = sd(mean_leq))

season <- ggplot() +
  geom_point(aes(x = Visit, y = mean, color = Category), data = season_dayavgl_20, position = position_dodge(width = 0.25), size = 1) +
  geom_errorbar(aes(x = Visit, ymax = mean + sd, ymin = mean - sd, color = Category), width = 0, data = season_dayavgl_20, position = position_dodge(width = 0.25), linewidth = 0.4) +
  geom_point(aes(x = Visit, y = mean_leq), color = "red", data = highlights) +
  geom_line(aes(x = as.numeric(Visit), y = response, color = Category, group = Category), data = predictions, linewidth = 0.5) +
  geom_ribbon(aes(x = as.numeric(Visit), ymax = response + SE, ymin = response - SE, color = Category, fill = Category, group = Category), alpha = 0.5, data = predictions) +
  geom_line(data = group2v3, aes(x= x, y = y, group=1), inherit.aes = F) +
  geom_label_repel(aes(x = Visit, y = mean_leq, label = mean_leq), color = "red", hjust = "right", data = highlights, size = 2) +
  xlab("Visit") +
  ylab("Daily average relative amplitude \n(Leq in dB re FS, 20-1000 Hz)") +
  scale_color_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_fill_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_x_discrete(labels=c("1" = "Aug 3-\nAug 20\n1", "2" = "Aug 31-\nSept 21\n2",
                              "3" = "Sept 22-\nOct 8\n3", "4" = "Oct 12-\nOct 23\n4")) +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        axis.title = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 10, color = "black", family = "sans"),
        legend.position = "none",
        panel.grid.major.y = element_line(colour = "black", linetype = "dashed", size = 0.1)) +
   annotate("text", x = 2.5, y = -50.75, label = "*", size = 6, color = "black") 

jpeg("figures/season.jpeg", width = 3.25, height = 3.5, units = "in", quality = 100, res = 600)
print(season)
dev.off()

season

predictions <- data.frame(allEffects(season.rlmer, residuals = TRUE)[[1]])
predictions <- predictions %>% 
  mutate(Visit2 = ifelse(Visit == "1", 1,
                         ifelse(Visit == "2", 2,
                                ifelse(Visit == "3", 3, 4))),
         Visit2 = as.numeric(Visit2),
         Category2 = ifelse(Category == "Urban", "Urban", "Rural"),
         Category2 = fct_relevel(Category2, "Rural", "Urban"))

season_robust <- ggplot() +
  geom_point(aes(x = Visit, y = mean, color = Category), data = season_dayavgl_20, position = position_dodge(width = 0.25), size = 1) +
  geom_errorbar(aes(x = Visit, ymax = mean + sd, ymin = mean - sd, color = Category), width = 0, data = season_dayavgl_20, position = position_dodge(width = 0.25), linewidth = 0.4) +  
  geom_line(aes(x = Visit2 + 0.25, y = fit, color = Category2), data = predictions) +
  geom_ribbon(aes(x = Visit2 + 0.25, ymax = fit + se, ymin = fit - se, color = Category2, fill = Category2), data = predictions, alpha = 0.5) +
  geom_line(data = group2v3, aes(x= x, y = y, group=1), inherit.aes = F) +
  xlab("Visit") +
  ylab("Daily average relative amplitude \n(Leq in dB re FS, 20-1000 Hz)") +
  scale_color_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_fill_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  scale_x_discrete(labels=c("1" = "Aug 3-\nAug 20\n1", "2" = "Aug 31-\nSept 21\n2",
                              "3" = "Sept 22-\nOct 8\n3", "4" = "Oct 12-\nOct 23\n4")) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        axis.title = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 8, color = "black", family = "sans"),
        legend.position = "top",
        legend.title = element_text(size = 8),
        panel.grid.major.y = element_line(colour = "black", linetype = "dashed", linewidth = 0.1)) +
    annotate("text", x = 2.5, y = -50.75, label = "*", size = 6, color = "black") 

jpeg("figures/season_robust.jpeg", 3.25, height = 2.75, units = "in", quality = 100, res = 300)
print(season_robust)
dev.off()

season_robust
```

To investigate whether noise varied across the season, we used a linear mixed model with visit number and category, and their interaction with site as a random factor. There was a trend that daily average Leq varied across the 2020 season (F = `r round(season.lmer.stats2[1,1], 2)`, df = `r season.lmer.stats$devcomp$dims[3]`, `r season.lmer.stats$devcomp$dims[1]`, P `r ifelse(round(season.lmer.stats2[1,4], 3) == 0, print("< 0.001"), print(paste("=", round(season.lmer.stats2[1,4], 3))))`, cond R$^2$ = `r round(R2c.s, 2)`, marg R$^2$ = `r round(R2m.s, 2)`). A post hoc test suggests that visit 3 was significantly louder than visit 2 (t = -3.002, P = 0.016). Also, urban areas are louder than rural areas (F = `r round(season.lmer.stats2[2,1], 2)`, P `r ifelse(round(season.lmer.stats2[2,4], 3) == 0, print("< 0.001"), print(paste("=", round(season.lmer.stats2[2,4], 3))))`). There is no interaction between visit and category (F = `r round(season.lmer.stats2[3,1], 2)`, P `r ifelse(round(season.lmer.stats2[3,4], 3) == 0, print("< 0.001"), print(paste("=", round(season.lmer.stats2[3,4], 3))))`). 

Let's look at date rather than visit. 

```{r season_date_rawplot, echo = FALSE, warning = FALSE, message = FALSE}
# let's first check out the raw data
ggplot(aes(x = Day, y = mean_leq, color = Category, group = Category), data = dayavgl_20) +
  geom_point() +
  geom_smooth(method = "loess") +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  scale_color_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_fill_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  ylab("Daily Average Leq (20-1000 Hz)") +
  theme_classic()
```

```{r season_date_stats, echo = FALSE, warning = FALSE, message = FALSE}
season.date.lmer <- lmer(mean_leq ~ Day * Category + (1|Site), data = dayavgl_20)
season.date.lmer.stats <- car::Anova(season.date.lmer)
season.date.lmer.stats2 <- summary(season.date.lmer)

season.date.rlmer <- rlmer(mean_leq ~ Day * Category + (1|Site), data = dayavgl_20)
season.date.rlmer.stats <- summary(season.date.rlmer)
coefs.robustr3 <- data.frame(coef(summary(season.date.rlmer)))
coefs.robustr3$P <- round(2*pt(abs(coefs.robustr3[,3]), season.date.lmer.stats2$devcomp$dims[4], lower=FALSE), 10)
```

We performed `r paste(season.date.lmer.stats2$call[1], "(", season.date.lmer.stats2$call[2], ", data = ", season.date.lmer.stats2$call[3], ")")` and found: 

```{r season_date_table, echo = FALSE, warning = FALSE, message = FALSE}
kable(season.date.lmer.stats)
```

Let's graph the results:

```{r season_date_graph, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}
predictions <- expand.grid(Day = seq(210, 300, 1),
                           Category = levels(factor(dayavgl_20$Category)))
predictions$response <- predict(season.date.lmer, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_season_date <- bootMer(season.date.lmer, myFunc, nsim = 1000)
#saveRDS(bigBoot_season_date, file = "data/bigBoot_season_date.Rds")
bigBoot_season_date <- readRDS("data/bigBoot_season_date.Rds")
predSE <- t(apply(bigBoot_season_date$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

season_date <- ggplot() +
  geom_point(aes(x = Day, y = mean_leq, color = Category, group = Category), data = dayavgl_20, alpha = 0.5) +
  geom_point(aes(x = Day, y = mean_leq), color = "red", data = highlights) +
  geom_line(aes(x = Day, y = response, color = Category, group = Category), data = predictions, size = 1) +
  geom_ribbon(aes(x = Day, ymax = response + SE, ymin = response - SE, color = Category, group = Category, fill = Category), data = predictions, alpha = 0.5, size = 1) +
  geom_label_repel(aes(x = Day, y = mean_leq, label = mean_leq), color = "red", hjust = "right", data = highlights, size = 2) +
  xlab("Day of the Year") +
  ylab("Daily Average Leq (dB, 20-1000 Hz)") +
  scale_color_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_fill_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_y_continuous(limits = c(-75, -50), breaks = c(-75, -70, -65, -60, -55, -50)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        axis.title = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 10, color = "black", family = "sans"),
        legend.position = "top",
        panel.grid.major.y = element_line(colour = "black", linetype = "dashed", size = 0.1)) 

jpeg("figures/season_date.jpeg", 4, height = 4, units = "in", quality = 100, res = 300)
print(season_date)
dev.off()

season_date
```

We see similar results by category (Chisq = `r round(season.date.lmer.stats[2,1], 2)`, df = `r season.date.lmer.stats2$devcomp$dims[3]`, `r season.date.lmer.stats2$devcomp$dims[1]`, P `r ifelse(round(season.date.lmer.stats[2,3], 4) == 0, print("< 0.001"), print(paste("=", round(season.date.lmer.stats[2,3], 3))))`), but with no difference over time (Chisq = `r round(season.date.lmer.stats[1,1], 2)`, P `r ifelse(round(season.date.lmer.stats[1,3], 4) == 0, print("< 0.001"), print(paste("=", round(season.date.lmer.stats[1,3], 3))))`, cond R$^2$ = `r round(r.squaredGLMM(season.date.lmer)[2], 2)`, marg R$^2$ = `r round(r.squaredGLMM(season.date.lmer)[1], 2)`) and no interaction (Chisq = `r round(season.date.lmer.stats[3,1], 2)`, P `r ifelse(round(season.date.lmer.stats[3,3], 4) == 0, print("< 0.001"), print(paste("=", round(season.date.lmer.stats[3,3], 3))))`). 

It seems like rural environments might be changing more over time. Let's investigate whether harvest might play a role.

```{r rural_harvest_rawplot, echo = FALSE, warning = FALSE, message = FALSE}
harvest_Lan <- readRDS("data/harvest_Lan.rds")

dayavgl_20_rural <- dayavgl_20 %>% 
  filter(Category == "Rural") %>% 
  mutate(mean_harvest = ifelse(Date < "2020-08-31", 0, 
                               ifelse(Date < "2020-09-06", 1,
                                      ifelse(Date < "2020-09-13", 2.5,
                                             ifelse(Date < "2020-09-20", 6.5,
                                                    ifelse(Date < "2020-09-27", 11.5,
                                                           ifelse(Date < "2020-10-04", 16.5,
                                                                  ifelse(Date < "2020-10-11", 20,
                                                                         ifelse(Date < "2020-10-18", 17, 
                                                                                ifelse(Date < "2020-10-25", 11.5))))))))))

ggplot(aes(x = mean_harvest, y = mean_leq), data = dayavgl_20_rural) +
  geom_point(color = "#1B9E77") +
  geom_smooth(method = "loess", color = "#1B9E77", fill = "#1B9E77", alpha = 0.5) +
  ylab("Daily Average Leq (20-1000 Hz)") +
  xlab("Week End Percent of Field Crop Harvested") +
  theme_classic()
```

```{r rural_harvest_stats, echo = FALSE, warning = FALSE, message = FALSE}
#harvest.lm <- lm(mean_leq ~ mean_harvest, data = dayavgl_20_rural)
#summary(harvest.lm)
harvest.lmer <- lmer(mean_leq ~ mean_harvest + (1 | Site), data = dayavgl_20_rural)
harvest.lmer.stats <- car::Anova(harvest.lmer)
harvest.lmer.stats2 <- summary(harvest.lmer)
var.fix <- get_variance_fixed(harvest.lmer)
var.ran <- get_variance_random(harvest.lmer)
var.res <- get_variance_residual(harvest.lmer)
R2m.h = var.fix / (var.fix + var.ran + var.res)
R2c.h = (var.fix + var.ran) / (var.fix + var.ran + var.res)

harvest.rlmer <- rlmer(mean_leq ~ mean_harvest + (1|Site), data = dayavgl_20_rural)
harvest.rlmer.stats <- summary(harvest.rlmer)
coefs.robustr.h <- data.frame(coef(harvest.rlmer.stats))
coefs.robustr.h$P <- round(2*pt(abs(coefs.robustr.h[,3]), harvest.rlmer.stats$devcomp$dims[4], lower=FALSE), 10)
var.fix <- get_variance_fixed(harvest.rlmer)
var.ran <- get_variance_random(harvest.rlmer)
var.res <- get_variance_residual(harvest.rlmer)
R2mr.h = var.fix / (var.fix + var.ran + var.res)
R2cr.h = (var.fix + var.ran) / (var.fix + var.ran + var.res)
```

We performed `r paste(harvest.lmer.stats2$call[1], "(", harvest.lmer.stats2$call[2], ", data = ", harvest.lmer.stats2$call[3], ")")` and `r harvest.rlmer.stats$call[1]`found: 

```{r rural_harvest_table, echo = FALSE, warning = FALSE, message = FALSE}
kable(harvest.lmer.stats)
kable(coefs.robustr.h)
```

Let's check the assumptions:

```{r rural_harvest_assump, echo = FALSE, warning = FALSE, message = FALSE}
test_harvest <- augment(harvest.lmer, data = dayavgl_20_rural)
resid_harvest <- ggplot(test_harvest, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_harvest$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_harvest <- ggplot(test_harvest, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_harvest, qq_harvest,  
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Let's graph the results: 

```{r rural_harvest_graph, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}
predictions <- expand.grid(mean_harvest = seq(0, 20, 0.2))
predictions$response <- predict(harvest.lmer, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_harvest <- bootMer(harvest.lmer, myFunc, nsim = 1000)
#saveRDS(bigBoot_harvest, file = "data/bigBoot_harvest.Rds")
bigBoot_harvest <- readRDS("data/bigBoot_harvest.Rds")
predSE <- t(apply(bigBoot_harvest$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

harvest <- ggplot() +
  geom_point(aes(x = mean_harvest, y = mean_leq), data = dayavgl_20_rural, color = "#1B9E77") +
  geom_line(aes(x = mean_harvest, y = response), data = predictions, size = 1) +
  geom_ribbon(aes(x = mean_harvest, ymax = response + SE, ymin = response - SE), data = predictions, color = "#1B9E77", fill = "#1B9E77", alpha = 0.5) +
  xlab("Week end % of field crop harvested") +
  ylab("Daily average relative amplitude \n(Leq in dB re FS, 20-1000 Hz)") +
  scale_y_continuous(limits = c(-75, -55), breaks = c(-75, -70, -65, -60, -55)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        axis.title = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 10, color = "black", family = "sans"),
        legend.position = "none",
        panel.grid.major.y = element_line(colour = "black", linetype = "dashed", size = 0.1)) 

jpeg("figures/harvest.jpeg", 3.25, height = 3, units = "in", quality = 100, res = 300)
print(harvest)
dev.off()

harvest

predictions <- data.frame(allEffects(harvest.rlmer, residuals = TRUE)[[1]])
harvest_robust <- ggplot() +
  geom_point(aes(x = mean_harvest, y = mean_leq), data = dayavgl_20_rural, color = "#1B9E77") +
  geom_line(aes(x = mean_harvest, y = fit), data = predictions, size = 1) +
  geom_ribbon(aes(x = mean_harvest, ymax = fit + se, ymin = fit - se), data = predictions, color = "#1B9E77", fill = "#1B9E77", alpha = 0.5) +
  xlab("Week end % of field crop harvested") +
  ylab("Daily average relative amplitude \n(Leq in dB re FS, 20-1000 Hz)") +
  scale_y_continuous(limits = c(-75, -55), breaks = c(-75, -70, -65, -60, -55)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        axis.text = element_text(size = 10, color = "black", family = "sans"),
        axis.title = element_text(size = 10, color = "black", family = "sans"),
        legend.text = element_text(size = 10, color = "black", family = "sans"),
        legend.position = "none",
        panel.grid.major.y = element_line(colour = "black", linetype = "dashed", size = 0.1)) 

jpeg("figures/harvest_robust.jpeg", 3.25, height = 3, units = "in", quality = 100, res = 300)
print(harvest_robust)
dev.off()

harvest_robust
```

We used USDA data on week end percent harvest in 2020 for field crops in Nebraska. This gave details on oats, wheat, dry beans, sorghum, corn, and soybeans. We restricted this list to corn and soybeans, as these are the major crops grown and harvested in Lancaster County, Nebraska. We took the mean week end percent harvested of these two crops during the study season and compared these to the rural recorded vibratory noise levels. The week end percent harvested was positively correlated with the daily average Leq for rural sites (t = `r round(coefs.robustr.h[2,3], 2)`, df = `r harvest.lmer.stats2$devcomp$dims[3]`, `r harvest.lmer.stats2$devcomp$dims[1]`, P `r ifelse(round(coefs.robustr.h[2,4], 3) == 0, print("< 0.001"), print(paste("=", round(coefs.robustr.h[2,4], 3))))`, cond R$^2$ = `r round(R2cr.h, 2)`, marg R$^2$ = `r round(R2mr.h, 2)`). 

## 24 Hours

```{r hourly_rawplot, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}
houravg <- houravgcatl %>% 
  group_by(Category, Hour) %>% 
  summarize(mean_leq = mean(meanleq),
            se_leq = plotrix::std.error(meanleq))

formatting_face <- ifelse(houravg$Hour == 8 | houravg$Hour == 9 | houravg$Hour == 15, "bold", "plain")
formatting_size <- ifelse(houravg$Hour == 8 | houravg$Hour == 9 | houravg$Hour == 15, 12, 10)

hourly_houravg <- houravgcatl %>% 
  dplyr::select(Category, Hour, meanleq) %>% 
  group_by(Hour, Category) %>% 
  summarise(mean = mean(meanleq),
            sd = sd(meanleq))

raw_hourly <- ggplot() +
  annotate("rect", xmin = -0.5, xmax = 7, ymin = -75, ymax = -42,
           alpha = 0.5,fill = "darkgrey") +
  annotate("rect", xmin = 19, xmax = 23.5, ymin = -75, ymax = -42,
           alpha = 0.5,fill = "darkgrey") +
  geom_point(aes(x = Hour, y = mean, color = Category), data = hourly_houravg, position = position_dodge(width = 0.25), size = 1) +
  geom_errorbar(aes(x = Hour, ymax = mean + sd, ymin = mean - sd, color = Category), data = hourly_houravg, position = position_dodge(width = 0.25), linewidth = 0.5, width = 0) +
  geom_vline(xintercept = 8, color = "#D95F02", linetype = "dashed", size = 0.5) +
  geom_vline(xintercept = 15, color = "#D95F02", linetype = "dashed", size = 0.5) +
  geom_vline(xintercept = 9, color = "#1B9E77", linetype = "dashed", size = 0.5) +
  geom_vline(xintercept = 15.1, color = "#1B9E77", linetype = "dashed", size = 0.5) +
  geom_line(aes(x = Hour, y = mean_leq, color = Category), data = houravg, linewidth = 0.5) +
  geom_ribbon(aes(x = Hour, ymin = mean_leq - se_leq, ymax = mean_leq + se_leq, fill = Category), data = houravg, alpha = 0.5) +
  xlab("Hour of day") +
  ylab("Hourly average relative amplitude \n(Leq in dB re FS, 20-1000 Hz)") +
  scale_color_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_fill_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_x_continuous(limits = c(-0.5, 23.5), breaks = seq(0, 23, 1), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-75, -42), breaks = c(-75, -70, -65, -60, -55, -50, -45), expand = c(0, 0)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        legend.position = "top",
        axis.text = element_text(size = formatting_size, color = "black", family = "sans", face = formatting_face))

jpeg("figures/raw_hourly.jpeg", 6.25, height = 3.5, units = "in", quality = 100, res = 600)
print(raw_hourly)
dev.off()

raw_hourly
```

Here we assessed how vibratory noise levels change throughout the day. We graph the calculated mean and standard error. The grey areas represent nighttime. We added vertical dashed lines where vibratory noise peaked throughout the day, coinciding with rush hours. This provides further evidence that road noise likely represents a large component of vibratory noise. We also see what would likely be significant differences by category following the findings across season. 

Let's look by visit as well

```{r hourly_visit_rawplot, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}
houravgvisit <- houravgcatl %>% 
  group_by(Category, Hour, Visit) %>% 
  summarize(mean_leq = mean(meanleq),
            se_leq = plotrix::std.error(meanleq))

formatting_face <- ifelse(houravgvisit$Hour == 8 | 
                            houravgvisit$Hour == 9 | 
                            houravgvisit$Hour == 15, "bold", "plain")
formatting_size <- ifelse(houravgvisit$Hour == 8 | 
                            houravgvisit$Hour == 9 | 
                            houravgvisit$Hour == 15, 12, 10)

hourly_visit_houravg <- houravgcatl %>% 
  dplyr::select(Category, Visit, Hour, meanleq) %>% 
  group_by(Hour, Category, Visit) %>% 
  summarise(mean = mean(meanleq),
            sd = sd(meanleq))

labs <- c("Visit 1: Aug 3-20",
          "Visit 2: Aug 31-Sept 21",
          "Visit 3: Sept 22-Oct 8",
          "Visit 4: Oct 12-23")
names(labs) <- c("1", "2", "3", "4")

raw_hourly_visit <- ggplot() +
  annotate("rect", xmin = -0.5, xmax = 7, ymin = -75, ymax = -42,
           alpha = 0.5,fill = "darkgrey") +
  annotate("rect", xmin = 19, xmax = 23.5, ymin = -75, ymax = -42,
           alpha = 0.5,fill = "darkgrey") +
  geom_point(aes(x = Hour, y = mean, color = Category), data = hourly_visit_houravg, position = position_dodge(width = 0.25), size = 1) +
  geom_errorbar(aes(x = Hour, ymax = mean + sd, ymin = mean - sd, color = Category), data = hourly_visit_houravg, position = position_dodge(width = 0.25), linewidth = 0.5, width = 0) +
  geom_vline(xintercept = 8, color = "#D95F02", linetype = "dashed", size = 0.5) +
  geom_vline(xintercept = 15, color = "#D95F02", linetype = "dashed", size = 0.5) +
  geom_vline(xintercept = 9, color = "#1B9E77", linetype = "dashed", size = 0.5) +
  geom_vline(xintercept = 15.1, color = "#1B9E77", linetype = "dashed", size = 0.5) +
  geom_line(aes(x = Hour, y = mean_leq, group = Category, color = Category), data = houravgvisit) +
  geom_ribbon(aes(x = Hour, ymin = mean_leq - se_leq, ymax = mean_leq + se_leq, fill = Category), data = houravgvisit, alpha = 0.5) +
  xlab("Hour of day") +
  ylab("Hourly average relative amplitude (Leq in dB re FS, 20-1000 Hz)") +
  scale_color_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_fill_manual("Category", values = c("#1B9E77", "#D95F02"),
                     labels = c("Rural", "Urban")) +
  scale_x_continuous(limits = c(-0.5, 23.5), breaks = seq(0, 23, 1), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-75, -42), breaks = c(-75, -70, -65, -60, -55, -50, -45), expand = c(0, 0)) +
  theme_classic() +
  theme(text = element_text(size = 10, color = "black", family = "sans"),
        legend.position = "top",
        axis.text = element_text(size = formatting_size, color = "black", family = "sans", face = formatting_face)) +
  facet_wrap(~Visit, ncol = 1, labeller = labeller(Visit = labs))

jpeg("figures/raw_hourly_visit.jpeg", 5, height = 9, units = "in", quality = 100, res = 300)
print(raw_hourly_visit)
dev.off()

raw_hourly_visit
```

# Stats Table

```{r stats_table, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}
noise_stats <- read.csv(file = "data/vibratory_noise_stats.csv", header = TRUE) # for predictor stats table

noise_stats <- noise_stats %>% 
  mutate(Variable = factor(Variable),
         Variable = fct_recode(Variable, "Rural/Urban" = "Category", "Potential Traffic Impact (PC1)" = "PC1", 
                               "Potential Traffic Impact (PC1) x Substrate" = "PC1xSubstrate",
                               "Visit x Rural/Urban" = "VisitxCategory",
                               "Precent Weekly Harvest" = "PerWeeklyHarvest"),
         Data = factor(Data),
         Data = fct_recode(Data, "Daily Average" = "DailyAvg1",
                                "Daily Average " = "DailyAvg2",
                                "Daily Average (Rural)" = "Rural",
                                "Daily Average (Urban)" = "Urban",
                                "Daily Average (2020)" = "DayAvg2020",
                                "Daily Average (2020, Rural)" = "DayAvg2020Rural"))

noise_stats[noise_stats == 0] <- ""

noise_stats <- noise_stats %>% 
  mutate(Pvalue = factor(Pvalue),
         Pvalue = fct_recode(Pvalue, "< 0.001 ***" = "0.001",
                        "   0.490" = "0.49",
                        "   0.002 **" = "0.002",
                        "   0.567" = "0.567",
                        "   0.935" = "0.935",
                        "   0.061 ." = "0.061",
                        "   0.146" = "0.146",
                        "   0.065 ." = "0.065",
                        "   0.318" = "0.318",
                        "   0.322" = "0.322"))

colnames(noise_stats) <- c('Noise Variation','Data (Subset by)','Variable', 'Test Statistic', 'N', 'P-Value', 'Cond. R²', 'Marg. R²')

flextable(noise_stats[ , 1:8]) %>% 
  autofit() %>% 
  merge_v(j = c('Noise Variation', 'Data (Subset by)', 'Cond. R²', 'Marg. R²'), part = "body") %>% 
  bold(bold = TRUE, part = "header") %>% 
  hline_bottom(part = "body", border = officer::fp_border(width = 2)) %>% 
  border(j = 'Noise Variation', border.bottom = officer::fp_border(width = 2)) %>% 
  hline(i = c("10"), part = "body", border = officer::fp_border(width = 2)) %>%   
  hline(i = c("1", "4", "7", "13"), j = c("2":"8"), part = "body", border = officer::fp_border(width = 1, color = "grey")) %>%     
  fontsize(size = 10, part = "all") %>% 
  align(align = "center", part = "all") %>% 
  valign(valign = "top", part = "all") %>% 
  footnote(i = c(5:7, 14), j = 4, ref_symbols = "a", value = as_paragraph("Results from a robust linear mixed effects model")) %>% 
    footnote(i = c(11:13), j = 4, ref_symbols = "b", value = as_paragraph("Results from a Type II Wald Chi-Squared test of a linear mixed effect model (test statistic = Chi-Squared)")) %>% 
  save_as_image(path = here::here("figures/noise_stats_table.png"))

flextable(noise_stats[ , 1:8]) %>% 
  autofit() %>% 
  merge_v(j = c('Noise Variation', 'Data (Subset by)', 'Cond. R²', 'Marg. R²'), part = "body") %>% 
  bold(bold = TRUE, part = "header") %>% 
  hline_bottom(part = "body", border = officer::fp_border(width = 2)) %>% 
  #border(j = 'Noise Variation', border.bottom = officer::fp_border(width = 2)) %>% 
  hline(i = c("10"), part = "body", border = officer::fp_border(width = 2)) %>%   
  hline(i = c("1", "4", "7", "13"), j = c("2":"8"), part = "body", border = officer::fp_border(width = 1, color = "grey")) %>%     
  fontsize(size = 10, part = "all") %>% 
  align(align = "center", part = "all") %>% 
  valign(valign = "top", part = "all") %>% 
  footnote(i = c(5:7, 14), j = 4, ref_symbols = "a", value = as_paragraph("Results from a robust linear mixed effects model")) %>% 
    footnote(i = c(11:13), j = 4, ref_symbols = "b", value = as_paragraph("Results from a Type II Wald Chi-Squared test of a linear mixed effect model (test statistic = Chi-Squared)"))
```

